"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.installCommand = exports.packageCommand = void 0;
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const jszip_1 = __importDefault(require("jszip"));
const ncp_1 = __importDefault(require("ncp"));
const os_1 = require("os");
const path_1 = require("path");
const rimraf_1 = __importDefault(require("rimraf"));
const util_1 = require("util");
const log_1 = require("./log");
const cpR = util_1.promisify(ncp_1.default);
// A fixed date is used for zip file modification timestamps to
// produce deterministic .foxe files. Foxglove birthday.
const MOD_DATE = new Date("2021-02-03");
var FileType;
(function (FileType) {
    FileType[FileType["File"] = 0] = "File";
    FileType[FileType["Directory"] = 1] = "Directory";
    FileType[FileType["FileOrDirectory"] = 2] = "FileOrDirectory";
})(FileType || (FileType = {}));
async function packageCommand(options = {}) {
    const extensionPath = options.cwd ?? process.cwd();
    const pkg = await readManifest(extensionPath);
    await prepublish(extensionPath, pkg);
    const files = await collect(extensionPath, pkg);
    const packagePath = path_1.normalize(options.packagePath ?? path_1.join(extensionPath, getPackageDirname(pkg) + ".foxe"));
    await writeFoxe(extensionPath, files, packagePath);
}
exports.packageCommand = packageCommand;
async function installCommand(options = {}) {
    const extensionPath = options.cwd ?? process.cwd();
    const pkg = await readManifest(extensionPath);
    await prepublish(extensionPath, pkg);
    const files = await collect(extensionPath, pkg);
    await install(files, extensionPath, pkg);
}
exports.installCommand = installCommand;
async function readManifest(extensionPath) {
    const pkgPath = path_1.join(extensionPath, "package.json");
    let pkg;
    try {
        pkg = JSON.parse(await promises_1.readFile(pkgPath, { encoding: "utf8" }));
    }
    catch (err) {
        throw new Error(`Failed to load ${pkgPath}: ${String(err)}`);
    }
    const manifest = pkg;
    if (typeof manifest.name !== "string") {
        throw new Error(`Missing required field "name" in ${pkgPath}`);
    }
    if (typeof manifest.version !== "string") {
        throw new Error(`Missing required field "version" in ${pkgPath}`);
    }
    if (typeof manifest.main !== "string") {
        throw new Error(`Missing required field "main" in ${pkgPath}`);
    }
    if (manifest.files != undefined && !Array.isArray(manifest.files)) {
        throw new Error(`Invalid "files" entry in ${pkgPath}`);
    }
    const publisher = manifest.publisher ?? parsePackageName(manifest.name).namespace;
    if (publisher == undefined || publisher.length === 0) {
        throw new Error(`Unknown publisher, add a "publisher" field to package.json`);
    }
    manifest.namespaceOrPublisher = publisher;
    return manifest;
}
async function prepublish(extensionPath, pkg) {
    const script = pkg.scripts?.["foxglove:prepublish"];
    if (script == undefined) {
        return;
    }
    log_1.info(`Executing prepublish script 'yarn run foxglove:prepublish'...`);
    await new Promise((c, e) => {
        const tool = "yarn";
        const cwd = extensionPath;
        const child = child_process_1.spawn(tool, ["run", "foxglove:prepublish"], {
            cwd,
            shell: true,
            stdio: "inherit",
        });
        child.on("exit", (code) => code === 0 ? c() : e(`${tool} failed with exit code ${code ?? "<null>"}`));
        child.on("error", e);
    });
}
async function collect(extensionPath, pkg) {
    const files = new Set();
    const baseFiles = [
        path_1.join(extensionPath, "package.json"),
        path_1.join(extensionPath, "README.md"),
        path_1.join(extensionPath, "CHANGELOG.md"),
        path_1.join(extensionPath, pkg.main),
    ];
    for (const file of baseFiles) {
        if (!(await pathExists(file, FileType.File))) {
            throw new Error(`Missing required file ${file}`);
        }
        files.add(file);
    }
    if (pkg.files != undefined) {
        for (const relFile of pkg.files) {
            const file = path_1.join(extensionPath, relFile);
            if (!inDirectory(extensionPath, file)) {
                throw new Error(`File ${file} is outside of the extension directory`);
            }
            if (!(await pathExists(file, FileType.FileOrDirectory))) {
                throw new Error(`Missing required path ${file}`);
            }
            files.add(file);
        }
    }
    else {
        const distDir = path_1.join(extensionPath, "dist");
        if (!(await pathExists(distDir, FileType.Directory))) {
            throw new Error(`Missing required directory ${distDir}`);
        }
        files.add(distDir);
    }
    return Array.from(files.values())
        .map((f) => path_1.relative(extensionPath, f))
        .sort();
}
async function writeFoxe(baseDir, files, outputFile) {
    const zip = new jszip_1.default();
    for (const file of files) {
        if (await isDirectory(path_1.join(baseDir, file))) {
            await addDirToZip(zip, baseDir, file);
        }
        else {
            addFileToZip(zip, baseDir, file);
        }
    }
    log_1.info(`Writing archive to ${outputFile}`);
    return new Promise((c, e) => {
        zip
            .generateNodeStream({ type: "nodebuffer", streamFiles: true })
            .pipe(fs_1.createWriteStream(outputFile, { encoding: "binary" }))
            .on("error", e)
            .on("finish", c);
    });
}
async function install(files, extensionPath, pkg) {
    process.chdir(extensionPath);
    const dirName = getPackageDirname(pkg);
    const destDir = path_1.join(os_1.homedir(), ".foxglove-studio", "extensions", dirName);
    await rmdir(destDir);
    await promises_1.mkdir(destDir, { recursive: true });
    log_1.info(`Copying files to ${destDir}`);
    for (const file of files) {
        const target = path_1.join(destDir, file);
        log_1.info(`${file} -> ${target}`);
        await cpR(file, target, { stopOnErr: true });
    }
}
async function pathExists(filename, fileType) {
    try {
        const finfo = await promises_1.stat(filename);
        switch (fileType) {
            case FileType.File:
                return finfo.isFile();
            case FileType.Directory:
                return finfo.isDirectory();
            case FileType.FileOrDirectory:
                return finfo.isFile() || finfo.isDirectory();
        }
    }
    catch {
        // ignore
    }
    return false;
}
async function isDirectory(pathname) {
    return (await promises_1.stat(pathname)).isDirectory();
}
function rmdir(dirname) {
    return new Promise((c, e) => rimraf_1.default(dirname, (err) => (err != undefined ? e(err) : c())));
}
async function addDirToZip(zip, baseDir, dirname) {
    const fullPath = path_1.join(baseDir, dirname);
    const entries = await promises_1.readdir(fullPath, { withFileTypes: true });
    for (const entry of entries) {
        const entryPath = path_1.join(dirname, entry.name);
        if (entry.isFile()) {
            addFileToZip(zip, baseDir, entryPath);
        }
        else if (entry.isDirectory()) {
            await addDirToZip(zip, baseDir, entryPath);
        }
    }
}
function addFileToZip(zip, baseDir, filename) {
    const fullPath = path_1.join(baseDir, filename);
    log_1.info(`archiving ${fullPath}`);
    zip.file(filename, fs_1.createReadStream(fullPath), { createFolders: true, date: MOD_DATE });
}
function getPackageDirname(pkg) {
    const pkgName = parsePackageName(pkg.name);
    return `${pkg.namespaceOrPublisher}.${pkgName.name}-${pkg.version}`;
}
function parsePackageName(name) {
    const res = /^@([^/]+)\/(.+)/.exec(name);
    if (res == undefined) {
        return { name };
    }
    return { namespace: res[1], name: res[2] };
}
function inDirectory(directory, pathname) {
    const relPath = path_1.relative(directory, pathname);
    const parts = relPath.split(path_1.sep);
    return parts[0] !== "..";
}
//# sourceMappingURL=package.js.map